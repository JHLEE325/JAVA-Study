## 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값

자바의 프리미티브 타입(primitive types) 은 총 8개이며, 언어 차원에서 미리 정의된 “값 타입”이다. <br>
프리미티브 타입은 아래처럼 나뉜다. <br>
- boolean
- 정수형(integral): `byte`, `short`, `int`, `long`, `char`
- 실수형(floating-point): `float`, `double`

#### `char`가 정수형인 이유
`char`는 문자 타입처럼 보이지만 부호 없는 16-bit 정수 타입
1. 자바의 `char`은 UTF-16 코드 유닛 하나를 저장
```java
char c = 'A';
int x = c; // 65
```
- `A` -> 65
- `가` -> 44032
- 문자를 직접 저장하는 것이 아니라 "문자의 코드 값"을 저장

2. JVM 연산 모델 단순화
JVM 바이트코드 관점에서
- `char`, `byte`, `short`는 연산 시 모두 int로 승격
- 정수 연산 파이프라인 하나로 처리 가능
```java
char a = 'A';
char b = 1;
// char c = a + b; // ❌ (int 결과)
char c = (char) (a + b);
```
- `char`를 정수 취급 함으로 산술연산, 비교연산, switch-case 모두 단순해짐
- 결론: Unicode 코드 포인트를 저장하는 unsigned 16-bit 정수로, JVM의 정수 연산 모델과 문자 처리의 단순화를 위해 정수형으로 설계

### 값의 범위
1. boolean
- 논리값 `true / false` 두 값만 표현한다.
- 크기 자체는 JVM 구현 / 메모리 레이아웃에 따라 달라질 수 있지만, 언어 스펙 관점에서 중요한 건 "참/거짓" 타입이라는 것

2. 정수형
- `byte`, `short`, `int`, `long` 은 2의 보수 기반 범위를 가진다.
- `char`는 부호 없는 16-bit 정수로, 0 ~ 65535(Unicode) 범위를 가진다.

| 타입    |      비트/바이트 | 범위                                                     |
| ----- | ----------: | ------------------------------------------------------ |
| byte  |  8-bit / 1B | -128 ~ 127                                             |
| short | 16-bit / 2B | -32,768 ~ 32,767                                       |
| int   | 32-bit / 4B | -2,147,483,648 ~ 2,147,483,647                         |
| long  | 64-bit / 8B | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
| char  | 16-bit / 2B | 0 ~ 65,535                                             |

3. 실수형
- `float`, `double` 은 IEEE 754 방식의 부동소수점 표현을 사용한다.(대략적인 근사값 저장)
- 0.1 같은 값도 이진 부동소수점으로 정확히 표현되지 않아 오차가 생길 수 있다.

| 타입     |      비트/바이트 | 대략적인 범위(대표 값)        |
| ------ | ----------: | -------------------- |
| float  | 32-bit / 4B | 약 1.4E-45 ~ 3.4E38   |
| double | 64-bit / 8B | 약 4.9E-324 ~ 1.7E308 |

### 기본값
**기본값**은 클래스 변수(static field), 인스턴스 변수(field), 배열 원소(array component)가 생성될 때 자동으로 채워지는 값

| 타입      | 기본값        |
| ------- | ---------- |
| boolean | `false`    |
| byte    | `(byte)0`  |
| short   | `(short)0` |
| int     | `0`        |
| long    | `0L`       |
| float   | `0.0f`     |
| double  | `0.0d`     |
| char    | `'\u0000'` |

#### 로컬 변수는 기본값이 없다
- 로컬 변수는 컴파일러가 초기화 보장을 강제한다.
- 초기화 없이 사용하면 **컴파일 에러**

### 알아둘만한 내용
1. `boolean`의 크기는?
- 자바 언어 스펙에는 명시하지 않음
- 논리 타입일 뿐 메모리 레이아웃은 JVM 구현체의 몫
- 1 byte 이다 -> 엄밀히 따지면 틀린 말

2. `byte`, `short`를 거의 쓰지 않는 이유?
- JVM에서 산술 연산 시 무조건 `int`로 승격됨
- 성능/메모리 이점이 거의 없음

3. 실수형의 MIN_VALUE
- 실수형의 MIN_VALUE는 가장 작은 음수가 아님
- 실수형의 중요한 포인트는 얼마나 작은 값까지 표현 가능한가 이다.
- 따라서 실수형의 MIN_VALUE는 0보다 크면서 0에 가장 가까운 값이고, 가장 작은 음수는 -MAX_VALUE로 표현함

---

## 2. 프리미티브 타입과 레퍼런스 타입

자바의 타입은 프리미티브 타입(Primitive Type)과 레퍼런스 타입(Reference Type) 중 하나로 분류됨

### 프리미티브 타입(Primitive Type)
프리미티브 타입은 값(value) 자체를 저장하는 타입

특징
- 객체가 아님 (`new` 불가)
- 변수에 실제 값이 직접 저장
- `null` 불가
- 비교시 `==`는 값 비교
- JVM 연산의 기본 단위 - 빠름
- 값이 복사됨
```java
int a = 10;
int b = a;

b = 20;
System.out.println(a); // 10
```

### 레퍼런스 타입(Reference Type)
레퍼런스 타입은 객체가 저장된 메모리 주소(참조값)을 저장한다. <br>
예시) 클래스(`String`, `Object`, 사용자 정의 클래스), 배열, 인터페이스, enum

특징
- 객체는 Heap 영역에 존재
- 변수에는 참조값만 저장
- `null` 가능
- `==`는 주소 비교
- 값 비교는 `equals()` 사용

#### 메모리 관점에서의 차이
프리미티브 타입
- 지역변수: JVM Stack
- 필드/배열 요소: Heap 내부 값

레퍼런스 타입
- 참조 변수: Stack
- 실제 객체: Heap
> 레퍼런스 타입은 스택에 저장된다. X -> 레퍼런스 변수는 스택, 객체는 힙에 저장된다. O

#### 비교 연산의 차이 (`==` vs `equals()`)
프리미티브 타입
```java
int a = 10;
int b = 10;

a == b; // true
```

레퍼런스 타입
```java
String a = new String("hi");
String b = new String("hi");

a == b;        // false (주소 비교)
a.equals(b);   // true (내용 비교)
```

#### null 처리의 차이
프리미티브 타입
```java
int x = null; // 컴파일 에러
```

레퍼런스 타입
```java
String s = null;

s.length(); // NullPointerException
```

#### 메서드 호출 시 동작 (Call by Value)
프리미티브 타입
```java
void change(int x) {
    x = 20;
}

int a = 10;
change(a);

System.out.println(a); // 10
```

레퍼런스 타입
```java
void change(Box b) {
    b.value = 20;
}

Box box = new Box();
box.value = 10;

change(box);
System.out.println(box.value); // 20
```
핵심
- 프리미티브: 값 복사
- 레퍼런스: 참조값 복사

##### Call by Value vs Call by Reference
개념 차이
- Call by Value: 인자로 값의 복사본이 전달 -> 호출된 함수 안에서 인자를 바꿔도, 호출자 변수는 영향 없음
- Call by Reference: 인자로 변수 그 자체가 전달됨 -> 호출된 함수 안에서 인자를 바꾸면, 호출자 변수도 바뀜

자바는 항상 Call by Value이다. 레퍼런스 타입의 경우 참조값이 복사되는 것으로 헷갈리는 것

```java
static void g(Box b) { b.value = 20; }

Box box = new Box();
box.value = 10;
g(box);
System.out.println(box.value); // 20
```
위에서 `box`가 바뀐 것 같지만, box 변수가 전달된 것이 아니라 box가 가지고 있던 참조값의 복사본이다.

```java
static void h(Box b) { b = new Box(); b.value = 99; }

Box box = new Box();
box.value = 10;
h(box);
System.out.println(box.value); // 10
```
Call by Reference 였다면 위의 값이 99로 바뀌었어야 함

#### Wrapper Class 와의 연결 포인트
프리미티브 타입은 객체가 아니므로 컬렉션, 제네릭, null 표현이 필요한 상황에서 Wrapper Class를 사용한다.
| Primitive | Wrapper     |
| --------- | ----------- |
| boolean   | `Boolean`   |
| byte      | `Byte`      |
| short     | `Short`     |
| int       | `Integer`   |
| long      | `Long`      |
| float     | `Float`     |
| double    | `Double`    |
| char      | `Character` |


#### 성능 관점 차이 (프리미티브 vs 래퍼/객체)
1. 메모리 사용량
- 프리미티브: 값 자체만 저장 -> 고정 크기(예: `int` 4바이트
- 래퍼/객체: 값 + 객체 헤더 + 정렬/패딩 + 참조 까지 필요 -> 같은 숫자 1개라도 훨씬 큰 메모리가 필요할 수 있음
- `int[]`는 연속 메모리라 밀도가 높고 캐시 효율이 좋음
- `Integer[]`/`List<Integer>`는 참조 배열 + 개별 객체라 메모리 파편화가 생기기 쉬움

2. CPU 비용 - 오토박싱/언박싱
- `List<Integer>`에 `int`를 넣으면 자동으로 박싱되고, 꺼낼 때 언박싱 됨
- 매번 큰 비용은 아닐 수 있으나 루프/대량 처리, 스트림/집계, 핫패스 에서는 누적 비용이 커짐

3. GC 부담
- 프리미티브 타입은 객체 생성이 없어서 GC 부담이 적음
- 래퍼/객체 타입은 많이 생성되면 Young GC를 자주 유발할 수 있음

---

