## 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값

자바의 프리미티브 타입(primitive types) 은 총 8개이며, 언어 차원에서 미리 정의된 “값 타입”이다. <br>
프리미티브 타입은 아래처럼 나뉜다. <br>
- boolean
- 정수형(integral): `byte`, `short`, `int`, `long`, `char`
- 실수형(floating-point): `float`, `double`

<br>

#### `char`가 정수형인 이유
`char`는 문자 타입처럼 보이지만 부호 없는 16-bit 정수 타입
1. 자바의 `char`은 UTF-16 코드 유닛 하나를 저장
```java
char c = 'A';
int x = c; // 65
```
- `A` -> 65
- `가` -> 44032
- 문자를 직접 저장하는 것이 아니라 "문자의 코드 값"을 저장

2. JVM 연산 모델 단순화
JVM 바이트코드 관점에서
- `char`, `byte`, `short`는 연산 시 모두 int로 승격
- 정수 연산 파이프라인 하나로 처리 가능
  ```java
    char a = 'A';
    char b = 1;
    // char c = a + b; // ❌ (int 결과)
    char c = (char) (a + b);
    ```
- `char`를 정수 취급 함으로 산술연산, 비교연산, switch-case 모두 단순해짐
- 결론: Unicode 코드 포인트를 저장하는 unsigned 16-bit 정수로, JVM의 정수 연산 모델과 문자 처리의 단순화를 위해 정수형으로 설계

<br>

### 값의 범위
1. boolean
- 논리값 `true / false` 두 값만 표현한다.
- 크기 자체는 JVM 구현 / 메모리 레이아웃에 따라 달라질 수 있지만, 언어 스펙 관점에서 중요한 건 "참/거짓" 타입이라는 것

2. 정수형
- `byte`, `short`, `int`, `long` 은 2의 보수 기반 범위를 가진다.
- `char`는 부호 없는 16-bit 정수로, 0 ~ 65535(Unicode) 범위를 가진다.
  | 타입    |      비트/바이트 | 범위                                                     |
    | ----- | ----------: | ------------------------------------------------------ |
    | byte  |  8-bit / 1B | -128 ~ 127                                             |
    | short | 16-bit / 2B | -32,768 ~ 32,767                                       |
    | int   | 32-bit / 4B | -2,147,483,648 ~ 2,147,483,647                         |
    | long  | 64-bit / 8B | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
    | char  | 16-bit / 2B | 0 ~ 65,535                                             |


3. 실수형
- `float`, `double` 은 IEEE 754 방식의 부동소수점 표현을 사용한다.(대략적인 근사값 저장)
- 0.1 같은 값도 이진 부동소수점으로 정확히 표현되지 않아 오차가 생길 수 있다.
  | 타입     |      비트/바이트 | 대략적인 범위(대표 값)        |
    | ------ | ----------: | -------------------- |
    | float  | 32-bit / 4B | 약 1.4E-45 ~ 3.4E38   |
    | double | 64-bit / 8B | 약 4.9E-324 ~ 1.7E308 |



<br>

### 기본값
**기본값**은 클래스 변수(static field), 인스턴스 변수(field), 배열 원소(array component)가 생성될 때 자동으로 채워지는 값

| 타입      | 기본값        |
| ------- | ---------- |
| boolean | `false`    |
| byte    | `(byte)0`  |
| short   | `(short)0` |
| int     | `0`        |
| long    | `0L`       |
| float   | `0.0f`     |
| double  | `0.0d`     |
| char    | `'\u0000'` |

#### 로컬 변수는 기본값이 없다
- 로컬 변수는 컴파일러가 초기화 보장을 강제한다.
- 초기화 없이 사용하면 **컴파일 에러**

<br>

### 알아둘만한 내용
1. `boolean`의 크기는?
- 자바 언어 스펙에는 명시하지 않음
- 논리 타입일 뿐 메모리 레이아웃은 JVM 구현체의 몫
- 1 byte 이다 -> 엄밀히 따지면 틀린 말

2. `byte`, `short`를 거의 쓰지 않는 이유?
- JVM에서 산술 연산 시 무조건 `int`로 승격됨
- 성능/메모리 이점이 거의 없음

3. 실수형의 MIN_VALUE
- 실수형의 MIN_VALUE는 가장 작은 음수가 아님
- 실수형의 중요한 포인트는 얼마나 작은 값까지 표현 가능한가 이다.
- 따라서 실수형의 MIN_VALUE는 0보다 크면서 0에 가장 가까운 값이고, 가장 작은 음수는 -MAX_VALUE로 표현함

---

## 2. 프리미티브 타입과 레퍼런스 타입

자바의 타입은 프리미티브 타입(Primitive Type)과 레퍼런스 타입(Reference Type) 중 하나로 분류됨

<br>

### 프리미티브 타입(Primitive Type)
프리미티브 타입은 값(value) 자체를 저장하는 타입

특징
- 객체가 아님 (`new` 불가)
- 변수에 실제 값이 직접 저장
- `null` 불가
- 비교시 `==`는 값 비교
- JVM 연산의 기본 단위 - 빠름
- 값이 복사됨
```java
int a = 10;
int b = a;

b = 20;
System.out.println(a); // 10
```

<br>

### 레퍼런스 타입(Reference Type)
레퍼런스 타입은 객체가 저장된 메모리 주소(참조값)을 저장한다. <br>
예시) 클래스(`String`, `Object`, 사용자 정의 클래스), 배열, 인터페이스, enum

특징
- 객체는 Heap 영역에 존재
- 변수에는 참조값만 저장
- `null` 가능
- `==`는 주소 비교
- 값 비교는 `equals()` 사용

<br>

#### 메모리 관점에서의 차이
프리미티브 타입
- 지역변수: JVM Stack
- 필드/배열 요소: Heap 내부 값

레퍼런스 타입
- 참조 변수: Stack
- 실제 객체: Heap
> 레퍼런스 타입은 스택에 저장된다. X -> 레퍼런스 변수는 스택, 객체는 힙에 저장된다. O

<br>

#### 비교 연산의 차이 (`==` vs `equals()`)
프리미티브 타입
```java
int a = 10;
int b = 10;

a == b; // true
```

레퍼런스 타입
```java
String a = new String("hi");
String b = new String("hi");

a == b;        // false (주소 비교)
a.equals(b);   // true (내용 비교)
```

<br>

#### null 처리의 차이
프리미티브 타입
```java
int x = null; // 컴파일 에러
```

레퍼런스 타입
```java
String s = null;

s.length(); // NullPointerException
```

<br>

#### 메서드 호출 시 동작 (Call by Value)
프리미티브 타입
```java
void change(int x) {
    x = 20;
}

int a = 10;
change(a);

System.out.println(a); // 10
```

레퍼런스 타입
```java
void change(Box b) {
    b.value = 20;
}

Box box = new Box();
box.value = 10;

change(box);
System.out.println(box.value); // 20
```
핵심
- 프리미티브: 값 복사
- 레퍼런스: 참조값 복사

<br>

##### Call by Value vs Call by Reference
개념 차이
- Call by Value: 인자로 값의 복사본이 전달 -> 호출된 함수 안에서 인자를 바꿔도, 호출자 변수는 영향 없음
- Call by Reference: 인자로 변수 그 자체가 전달됨 -> 호출된 함수 안에서 인자를 바꾸면, 호출자 변수도 바뀜

자바는 항상 Call by Value이다. 레퍼런스 타입의 경우 참조값이 복사되는 것으로 헷갈리는 것

```java
static void g(Box b) { b.value = 20; }

Box box = new Box();
box.value = 10;
g(box);
System.out.println(box.value); // 20
```
위에서 `box`가 바뀐 것 같지만, box 변수가 전달된 것이 아니라 box가 가지고 있던 참조값의 복사본이다.

```java
static void h(Box b) { b = new Box(); b.value = 99; }

Box box = new Box();
box.value = 10;
h(box);
System.out.println(box.value); // 10
```
Call by Reference 였다면 위의 값이 99로 바뀌었어야 함

<br>

#### Wrapper Class 와의 연결 포인트
프리미티브 타입은 객체가 아니므로 컬렉션, 제네릭, null 표현이 필요한 상황에서 Wrapper Class를 사용한다.
| Primitive | Wrapper     |
| --------- | ----------- |
| boolean   | `Boolean`   |
| byte      | `Byte`      |
| short     | `Short`     |
| int       | `Integer`   |
| long      | `Long`      |
| float     | `Float`     |
| double    | `Double`    |
| char      | `Character` |


<br>

#### 성능 관점 차이 (프리미티브 vs 래퍼/객체)
1. 메모리 사용량
- 프리미티브: 값 자체만 저장 -> 고정 크기(예: `int` 4바이트
- 래퍼/객체: 값 + 객체 헤더 + 정렬/패딩 + 참조 까지 필요 -> 같은 숫자 1개라도 훨씬 큰 메모리가 필요할 수 있음
- `int[]`는 연속 메모리라 밀도가 높고 캐시 효율이 좋음
- `Integer[]`/`List<Integer>`는 참조 배열 + 개별 객체라 메모리 파편화가 생기기 쉬움

2. CPU 비용 - 오토박싱/언박싱
- `List<Integer>`에 `int`를 넣으면 자동으로 박싱되고, 꺼낼 때 언박싱 됨
- 매번 큰 비용은 아닐 수 있으나 루프/대량 처리, 스트림/집계, 핫패스 에서는 누적 비용이 커짐

3. GC 부담
- 프리미티브 타입은 객체 생성이 없어서 GC 부담이 적음
- 래퍼/객체 타입은 많이 생성되면 Young GC를 자주 유발할 수 있음

---

## 3. 리터럴(Literal)

리터럴이란 소스 코드에 직접 작성된 값 자체<br>
즉, 이미 값이 정해진 상태로 코드에 포함된 데이터
```java
int a = 10;      // 10 → 정수 리터럴
String s = "hi"; // "hi" → 문자열 리터럴
```

<br>

### 리터럴의 종류

#### 1. 정수 리터럴
기본 타입은 int
```java
int decimal = 26;	   // 일반적인 형태 10진법
int ocatal = 032;        // 제일 앞에 0 이 붙으면 8진법 
int heaxaDecimal = 0x1a; // 0x가 붙으면 16진법 
int binary = 0b11010;    // 0b가 붙으면 2진법 
```
long 리터럴
```java
long x = 10L;
long y = 2147483648;  // ❌ int 범위 초과
long y = 2147483648L; // ⭕
```

#### 2. 실수 리터럴
기본 타입은 double - 정밀도 + 하드웨어 친화성
```java
double a = 3.14;
```
float 리터럴
```java
float b = 3.14f;
```
> 실수 리터럴은 정확한 10진 표현이 아니다

#### 3. 문자 리터럴
```java
char a = 'A';
char b = '\n';
char c = '\u0041'; // 'A'
```
따옴표로 표시하며 본래는 정수 리터럴이고 특수형태이다

#### 문자열 리터럴
```java
String s1 = "hello";
String s2 = "hello";
```
String Pool 과 직접적으로 연결되는 포인트

#### boolean 리터럴
```java
boolean a = true;
boolean b = false;
```

#### null 리터럴
```java
String s = null;
```
특징
- 모든 레퍼런스 타입에 대입 가능, 프리미티브 타입에는 불가

<br>

### String 리터럴과 String Pool

#### 문자열 리터럴은 특별하다
```java
String a = "java";
String b = "java";
a == b; // true
```
- JVM은 문자열 리터럴을 String Constant Pool에 저장한다
- 같은 리터럴은 하나의 객체만 생성한다
- 따라서 위에서 `a`와 `b`는 같은 객체를 참조한다
- 이 때문에 `==` 연산이 true로 나옴

#### `new String()`과 차이
```java
String a = "java";
String b = new String("java");

a == b;        // false
a.equals(b);   // true
```
- `new String()` -> Heap에 항상 새 객체
- 리터럴 -> Pool 재사용

---

## 4. 변수 선언 및 초기화 방법
자바에서 변수는 값을 저장할 수 있는 이름 붙은 메모리 공간 <br>
모든 변수는 선언 시점에 반드시 타입이 정해져야 함

<br>

### 변수 선언
변수의 타입, 변수 이름을 입력하여 메모리 공간을 확보하는 일
```java
int x;
```
`int` 타입으로 `x`라는 4바이트 메모리 공간을 만든다

<br>

### 변수 초기화
확보된 메모리 공간에 최초의 값을 대입하는 일
```java
x = 10;
int y = 20;
```
x라는 메모리 공간에 10의 값을 대입한다 <br>
선언과 초기화를 동시에 할 수 있다

<br>

### 변수 종류에 따른 초기화 규칙
자바에서 초기화 강제 여부는 변수의 종류에 따라 다르다

#### 1. 로컬 변수
```java
void foo() {
    int x;
    System.out.println(x); // ❌ 컴파일 에러
}
```
- 자동 초기화 되지 않음
- 반드시 개발자가 직접 초기화 해야 함
- 컴파일 타임에 초기화 여부 검사
- 로컬 변수는 스택 영역으로 JVM이 기본값을 넣으면 불필요한 성능 비용, 잠재적 논리 오류 발생

#### 2. 인스턴스 변수 (필드)
```java
class A {
    int x;
}
A a = new A();
System.out.println(a.x); // 0
```
- 자동 초기화 실행
- 객체 생성 시 Heap에서 기본값으로 채워짐

#### 3. static 변수 (클래스 변수)
```java
class B {
    static int y;
}
System.out.println(B.y); // 0
```
- 클래스 로딩 시 자동 초기화
- Method Area / Metaspace에 존재

#### 4. 배열의 요소
```java
int[] arr = new int[3];
System.out.println(arr[0]); // 0
```
- 배열 자체는 레퍼런스 타입으로 각 요소는 기본값으로 초기화됨

<br>

### 초기화 순서
초기화 순서는 객체/클래스의 상태가 기본값에서 정상값으로 전이되는 과정을 결정하고<br>
필드 초기화가 서로 의존하거나 상속, static 초기화 또는 예외가 얽히면 결과가 달라지거나 클래스 초기화 실패로 장애가 커질 수 있음
```java
class Test {
    static int a = 1;
    int b = 2;

    static {
        a = 3;
    }

    {
        b = 4;
    }

    Test() {
        b = 5;
    }
}
```
#### 실행 순서
1. static 변수 기본값
2. static 초기화 블록
3. 인스턴스 변수 기본값
4. 인스턴스 초기화 블록
5. 생성자
