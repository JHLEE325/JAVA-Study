## 1. 프리미티브 타입 종류와 값의 범위 그리고 기본 값

자바의 프리미티브 타입(primitive types) 은 총 8개이며, 언어 차원에서 미리 정의된 “값 타입”이다. <br>
프리미티브 타입은 아래처럼 나뉜다. <br>
- boolean
- 정수형(integral): `byte`, `short`, `int`, `long`, `char`
- 실수형(floating-point): `float`, `double`

<br>

#### `char`가 정수형인 이유
`char`는 문자 타입처럼 보이지만 부호 없는 16-bit 정수 타입
1. 자바의 `char`은 UTF-16 코드 유닛 하나를 저장
```java
char c = 'A';
int x = c; // 65
```
- `A` -> 65
- `가` -> 44032
- 문자를 직접 저장하는 것이 아니라 "문자의 코드 값"을 저장

2. JVM 연산 모델 단순화
JVM 바이트코드 관점에서
- `char`, `byte`, `short`는 연산 시 모두 int로 승격
- 정수 연산 파이프라인 하나로 처리 가능
  ```java
    char a = 'A';
    char b = 1;
    // char c = a + b; // ❌ (int 결과)
    char c = (char) (a + b);
    ```
- `char`를 정수 취급 함으로 산술연산, 비교연산, switch-case 모두 단순해짐
- 결론: Unicode 코드 포인트를 저장하는 unsigned 16-bit 정수로, JVM의 정수 연산 모델과 문자 처리의 단순화를 위해 정수형으로 설계

<br>

### 값의 범위
1. boolean
- 논리값 `true / false` 두 값만 표현한다.
- 크기 자체는 JVM 구현 / 메모리 레이아웃에 따라 달라질 수 있지만, 언어 스펙 관점에서 중요한 건 "참/거짓" 타입이라는 것

2. 정수형
- `byte`, `short`, `int`, `long` 은 2의 보수 기반 범위를 가진다.
- `char`는 부호 없는 16-bit 정수로, 0 ~ 65535(Unicode) 범위를 가진다.
  | 타입    |      비트/바이트 | 범위                                                     |
    | ----- | ----------: | ------------------------------------------------------ |
    | byte  |  8-bit / 1B | -128 ~ 127                                             |
    | short | 16-bit / 2B | -32,768 ~ 32,767                                       |
    | int   | 32-bit / 4B | -2,147,483,648 ~ 2,147,483,647                         |
    | long  | 64-bit / 8B | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 |
    | char  | 16-bit / 2B | 0 ~ 65,535                                             |


3. 실수형
- `float`, `double` 은 IEEE 754 방식의 부동소수점 표현을 사용한다.(대략적인 근사값 저장)
- 0.1 같은 값도 이진 부동소수점으로 정확히 표현되지 않아 오차가 생길 수 있다.
  | 타입     |      비트/바이트 | 대략적인 범위(대표 값)        |
    | ------ | ----------: | -------------------- |
    | float  | 32-bit / 4B | 약 1.4E-45 ~ 3.4E38   |
    | double | 64-bit / 8B | 약 4.9E-324 ~ 1.7E308 |



<br>

### 기본값
**기본값**은 클래스 변수(static field), 인스턴스 변수(field), 배열 원소(array component)가 생성될 때 자동으로 채워지는 값

| 타입      | 기본값        |
| ------- | ---------- |
| boolean | `false`    |
| byte    | `(byte)0`  |
| short   | `(short)0` |
| int     | `0`        |
| long    | `0L`       |
| float   | `0.0f`     |
| double  | `0.0d`     |
| char    | `'\u0000'` |

#### 로컬 변수는 기본값이 없다
- 로컬 변수는 컴파일러가 초기화 보장을 강제한다.
- 초기화 없이 사용하면 **컴파일 에러**

<br>

### 알아둘만한 내용
1. `boolean`의 크기는?
- 자바 언어 스펙에는 명시하지 않음
- 논리 타입일 뿐 메모리 레이아웃은 JVM 구현체의 몫
- 1 byte 이다 -> 엄밀히 따지면 틀린 말

2. `byte`, `short`를 거의 쓰지 않는 이유?
- JVM에서 산술 연산 시 무조건 `int`로 승격됨
- 성능/메모리 이점이 거의 없음

3. 실수형의 MIN_VALUE
- 실수형의 MIN_VALUE는 가장 작은 음수가 아님
- 실수형의 중요한 포인트는 얼마나 작은 값까지 표현 가능한가 이다.
- 따라서 실수형의 MIN_VALUE는 0보다 크면서 0에 가장 가까운 값이고, 가장 작은 음수는 -MAX_VALUE로 표현함

---

## 2. 프리미티브 타입과 레퍼런스 타입

자바의 타입은 프리미티브 타입(Primitive Type)과 레퍼런스 타입(Reference Type) 중 하나로 분류됨

<br>

### 프리미티브 타입(Primitive Type)
프리미티브 타입은 값(value) 자체를 저장하는 타입

특징
- 객체가 아님 (`new` 불가)
- 변수에 실제 값이 직접 저장
- `null` 불가
- 비교시 `==`는 값 비교
- JVM 연산의 기본 단위 - 빠름
- 값이 복사됨
```java
int a = 10;
int b = a;

b = 20;
System.out.println(a); // 10
```

<br>

### 레퍼런스 타입(Reference Type)
레퍼런스 타입은 객체가 저장된 메모리 주소(참조값)을 저장한다. <br>
예시) 클래스(`String`, `Object`, 사용자 정의 클래스), 배열, 인터페이스, enum

특징
- 객체는 Heap 영역에 존재
- 변수에는 참조값만 저장
- `null` 가능
- `==`는 주소 비교
- 값 비교는 `equals()` 사용

<br>

#### 메모리 관점에서의 차이
프리미티브 타입
- 지역변수: JVM Stack
- 필드/배열 요소: Heap 내부 값

레퍼런스 타입
- 참조 변수: Stack
- 실제 객체: Heap
> 레퍼런스 타입은 스택에 저장된다. X -> 레퍼런스 변수는 스택, 객체는 힙에 저장된다. O

<br>

#### 비교 연산의 차이 (`==` vs `equals()`)
프리미티브 타입
```java
int a = 10;
int b = 10;

a == b; // true
```

레퍼런스 타입
```java
String a = new String("hi");
String b = new String("hi");

a == b;        // false (주소 비교)
a.equals(b);   // true (내용 비교)
```

<br>

#### null 처리의 차이
프리미티브 타입
```java
int x = null; // 컴파일 에러
```

레퍼런스 타입
```java
String s = null;

s.length(); // NullPointerException
```

<br>

#### 메서드 호출 시 동작 (Call by Value)
프리미티브 타입
```java
void change(int x) {
    x = 20;
}

int a = 10;
change(a);

System.out.println(a); // 10
```

레퍼런스 타입
```java
void change(Box b) {
    b.value = 20;
}

Box box = new Box();
box.value = 10;

change(box);
System.out.println(box.value); // 20
```
핵심
- 프리미티브: 값 복사
- 레퍼런스: 참조값 복사

<br>

##### Call by Value vs Call by Reference
개념 차이
- Call by Value: 인자로 값의 복사본이 전달 -> 호출된 함수 안에서 인자를 바꿔도, 호출자 변수는 영향 없음
- Call by Reference: 인자로 변수 그 자체가 전달됨 -> 호출된 함수 안에서 인자를 바꾸면, 호출자 변수도 바뀜

자바는 항상 Call by Value이다. 레퍼런스 타입의 경우 참조값이 복사되는 것으로 헷갈리는 것

```java
static void g(Box b) { b.value = 20; }

Box box = new Box();
box.value = 10;
g(box);
System.out.println(box.value); // 20
```
위에서 `box`가 바뀐 것 같지만, box 변수가 전달된 것이 아니라 box가 가지고 있던 참조값의 복사본이다.

```java
static void h(Box b) { b = new Box(); b.value = 99; }

Box box = new Box();
box.value = 10;
h(box);
System.out.println(box.value); // 10
```
Call by Reference 였다면 위의 값이 99로 바뀌었어야 함

<br>

#### Wrapper Class 와의 연결 포인트
프리미티브 타입은 객체가 아니므로 컬렉션, 제네릭, null 표현이 필요한 상황에서 Wrapper Class를 사용한다.
| Primitive | Wrapper     |
| --------- | ----------- |
| boolean   | `Boolean`   |
| byte      | `Byte`      |
| short     | `Short`     |
| int       | `Integer`   |
| long      | `Long`      |
| float     | `Float`     |
| double    | `Double`    |
| char      | `Character` |


<br>

#### 성능 관점 차이 (프리미티브 vs 래퍼/객체)
1. 메모리 사용량
- 프리미티브: 값 자체만 저장 -> 고정 크기(예: `int` 4바이트
- 래퍼/객체: 값 + 객체 헤더 + 정렬/패딩 + 참조 까지 필요 -> 같은 숫자 1개라도 훨씬 큰 메모리가 필요할 수 있음
- `int[]`는 연속 메모리라 밀도가 높고 캐시 효율이 좋음
- `Integer[]`/`List<Integer>`는 참조 배열 + 개별 객체라 메모리 파편화가 생기기 쉬움

2. CPU 비용 - 오토박싱/언박싱
- `List<Integer>`에 `int`를 넣으면 자동으로 박싱되고, 꺼낼 때 언박싱 됨
- 매번 큰 비용은 아닐 수 있으나 루프/대량 처리, 스트림/집계, 핫패스 에서는 누적 비용이 커짐

3. GC 부담
- 프리미티브 타입은 객체 생성이 없어서 GC 부담이 적음
- 래퍼/객체 타입은 많이 생성되면 Young GC를 자주 유발할 수 있음

---

## 3. 리터럴(Literal)

리터럴이란 소스 코드에 직접 작성된 값 자체<br>
즉, 이미 값이 정해진 상태로 코드에 포함된 데이터
```java
int a = 10;      // 10 → 정수 리터럴
String s = "hi"; // "hi" → 문자열 리터럴
```

<br>

### 리터럴의 종류

#### 1. 정수 리터럴
기본 타입은 int
```java
int decimal = 26;	   // 일반적인 형태 10진법
int ocatal = 032;        // 제일 앞에 0 이 붙으면 8진법 
int heaxaDecimal = 0x1a; // 0x가 붙으면 16진법 
int binary = 0b11010;    // 0b가 붙으면 2진법 
```
long 리터럴
```java
long x = 10L;
long y = 2147483648;  // ❌ int 범위 초과
long y = 2147483648L; // ⭕
```

#### 2. 실수 리터럴
기본 타입은 double - 정밀도 + 하드웨어 친화성
```java
double a = 3.14;
```
float 리터럴
```java
float b = 3.14f;
```
> 실수 리터럴은 정확한 10진 표현이 아니다

#### 3. 문자 리터럴
```java
char a = 'A';
char b = '\n';
char c = '\u0041'; // 'A'
```
따옴표로 표시하며 본래는 정수 리터럴이고 특수형태이다

#### 문자열 리터럴
```java
String s1 = "hello";
String s2 = "hello";
```
String Pool 과 직접적으로 연결되는 포인트

#### boolean 리터럴
```java
boolean a = true;
boolean b = false;
```

#### null 리터럴
```java
String s = null;
```
특징
- 모든 레퍼런스 타입에 대입 가능, 프리미티브 타입에는 불가

<br>

### String 리터럴과 String Pool

#### 문자열 리터럴은 특별하다
```java
String a = "java";
String b = "java";
a == b; // true
```
- JVM은 문자열 리터럴을 String Constant Pool에 저장한다
- 같은 리터럴은 하나의 객체만 생성한다
- 따라서 위에서 `a`와 `b`는 같은 객체를 참조한다
- 이 때문에 `==` 연산이 true로 나옴

#### `new String()`과 차이
```java
String a = "java";
String b = new String("java");

a == b;        // false
a.equals(b);   // true
```
- `new String()` -> Heap에 항상 새 객체
- 리터럴 -> Pool 재사용

---

## 4. 변수 선언 및 초기화 방법
자바에서 변수는 값을 저장할 수 있는 이름 붙은 메모리 공간 <br>
모든 변수는 선언 시점에 반드시 타입이 정해져야 함

<br>

### 변수 선언
변수의 타입, 변수 이름을 입력하여 메모리 공간을 확보하는 일
```java
int x;
```
`int` 타입으로 `x`라는 4바이트 메모리 공간을 만든다

<br>

### 변수 초기화
확보된 메모리 공간에 최초의 값을 대입하는 일
```java
x = 10;
int y = 20;
```
x라는 메모리 공간에 10의 값을 대입한다 <br>
선언과 초기화를 동시에 할 수 있다

<br>

### 변수 종류에 따른 초기화 규칙
자바에서 초기화 강제 여부는 변수의 종류에 따라 다르다

#### 1. 로컬 변수
```java
void foo() {
    int x;
    System.out.println(x); // ❌ 컴파일 에러
}
```
- 자동 초기화 되지 않음
- 반드시 개발자가 직접 초기화 해야 함
- 컴파일 타임에 초기화 여부 검사
- 로컬 변수는 스택 영역으로 JVM이 기본값을 넣으면 불필요한 성능 비용, 잠재적 논리 오류 발생

#### 2. 인스턴스 변수 (필드)
```java
class A {
    int x;
}
A a = new A();
System.out.println(a.x); // 0
```
- 자동 초기화 실행
- 객체 생성 시 Heap에서 기본값으로 채워짐

#### 3. static 변수 (클래스 변수)
```java
class B {
    static int y;
}
System.out.println(B.y); // 0
```
- 클래스 로딩 시 자동 초기화
- Method Area / Metaspace에 존재

#### 4. 배열의 요소
```java
int[] arr = new int[3];
System.out.println(arr[0]); // 0
```
- 배열 자체는 레퍼런스 타입으로 각 요소는 기본값으로 초기화됨

<br>

### 초기화 순서
초기화 순서는 객체/클래스의 상태가 기본값에서 정상값으로 전이되는 과정을 결정하고<br>
필드 초기화가 서로 의존하거나 상속, static 초기화 또는 예외가 얽히면 결과가 달라지거나 클래스 초기화 실패로 장애가 커질 수 있음
```java
class Test {
    static int a = 1;
    int b = 2;

    static {
        a = 3;
    }

    {
        b = 4;
    }

    Test() {
        b = 5;
    }
}
```
#### 실행 순서
1. static 변수 기본값
2. static 초기화 블록
3. 인스턴스 변수 기본값
4. 인스턴스 초기화 블록
5. 생성자

---

## 5. 변수의 스코프(Scope)와 라이프타임(Lifetime)
자바에서 변수는 "어디에서 접근 가능한가(Scope)"와 "언제 생성되고 언제 사라지는가(Lifetime)"가 명확히 구분된다.

<br>

### 스코프란?
스코프는 변수가 접근 가능한 코드 범위 - 컴파일 타임 개념
```java
void foo() {
    int x = 10;
    if (true) {
        int y = 20;
        System.out.println(x); // ⭕
    }
    System.out.println(y); // ❌ 컴파일 에러
}
```
- `x`의 스코프: `foo()` 메서드 블록 전체
- `y`의 스코프: `if` 블록 내부
- 블록 `{}` 기준으로 결정

<br>

### 라이프타임이란?
라이프타임은 변수가 메모리에 실제로 존재하는 시간 - 런타임 개념
- 스택에 언제 올라가고
- 힙에서 언제 GC 되는지

<br>

### 스코프와 라이프타임의 차이
| 구분    | 스코프      | 라이프타임     |
| ----- | -------- | --------- |
| 기준    | 접근 가능 범위 | 메모리 존재 시간 |
| 관점    | 컴파일 타임   | 런타임       |
| 결정 주체 | 컴파일러     | JVM       |
| 오류    | 컴파일 에러   | 런타임 오류/GC |

<br>

### 변수 종류별 스코프와 라이프타임
#### 1. 로컬 변수 (Local Variable)
```java
void foo() {
    int x = 10;
}
```
**스코프**
- 선언된 블록 내부 `{}`

**라이프타임**
- 메서드 호출 시 스택 프레임 생성
- 메서도 종료 시 스택 프레임 제거 -> 소멸

**특징**
- 자동 초기화 되지 않음
- 짧은 라이프 타임
- GC 대상 아님

#### 2. 매개변수 (Parameter)
```java
void foo(int x) {
    System.out.println(x);
}
```
**스코프**
- 메서드 내부

**라이프타임**
- 메서드 호출 ~ 종료

**특징**
- 사실상 로컬 변수의 한 종류

#### 3. 인스턴스 변수 (Instance Variable, 필드)
```java
class A {
    int x;
}
```
**스코프**
- 클래스 내부
- 객체 참조를 통해 접근

**라이프타임**
- 객체 생성 시 Heap에 할당
- GC 대상
- 더이상 참조되지 않으면 소멸

**특징**
- 객체의 생명주기와 동일

#### 4. static 변수 (클래스 변수)
```java
class B {
    static int y;
}
```
**스코프**
- 클래스 전체
- 클래스명으로 접근

**라이프타임**
- 클래스 로딩 시 생성
- JVM 종료 시 소멸

**특징**
- GC 대상 아님 (메타데이터 영역)

<br>

### 블록 스코프와 변수 섀도잉(Shadowing)
#### 블록 스코프
```java
int x = 10;
{
    int x = 20; // 컴파일 에러
}
```
- 같은 스코프 체인에서 중복 선언 불가

#### 변수 섀도잉
```java
class A {
    int x = 10;

    void foo(int x) {
        System.out.println(x); // 파라미터 x
        System.out.println(this.x); // 필드 x
    }
}
```
- 가까운 스코프가 우선
- 필드는 `this`로 구분
- 실무에서는 지양되는 행위

---

## 6. 타입 변환(Type Conversion), 캐스팅(Casting), 타입 프로모션(Type Promotion)

자바에서 타입 변환은 서로 다른 타입 간에 값을 이동시키는 규칙 <br>
자바는 타입 안정성을 매우 중요하게 여기기 때문에 모든 타입 변환은 명시적이거나, 규칙에 의해 허용됨 <br>
자바의 타입 변환은 크게 자동 타입 변환 (Implict / Promotion), 명시적 타입 변환 (Explicit / Casting) 으로 나뉜다.

### 자동 타입 변환 (Type Promotion)
개념 - 작은 범위의 타입 -> 큰 범위의 타입으로 <br>
데이터 손실 위험이 없을 때 JVM이 자동으로 변환

#### 프리미티브 타입 프로모션 규칙
정수 타입 확장: byte -> short -> int -> long
실수 타입 확장: float -> double
정수 + 실수 연산: 정수 -> 실수
특수 규칙: 연산 시 최소 int 승격
```java
byte a = 10;
byte b = 20;

// byte c = a + b; // ❌
int c = a + b;     // ⭕
```
이유: JVM 산술 연산이 기본적으로 int 단위

<br>

### 명시적 타입 변환 (Casting)
개념 - 큰 범위 -> 작은 범위 타입으로의 이동 또는 데이터 손실 가능성이 있는 변환
```java
long a = 10L;
int b = (int) a;
```

#### 데이터 손실 예시
```java
int x = (int) 3.14; // 3
```
- 소수점 이하 버림
```java
int y = (int) 1_000_000_000_000L;
```
- 오버플로우 발생, 값 보장 안됨

<br>

### char 관련 타입 변환
char -> int는 자동으로 되지만 <br>
int -> char 는 명시적으로 이루어진다
```java
char c = 'A';
int x = c; // 65
int y = 65;
char d = (char) y; // 'A'
```

<br>

### 연산 시 타입 변환 규칙
1. 피연산자 중 가장 큰 타입으로 승격
2. byte/short/char 는 모두 최소 int로 승격
3. 실수가 있으면 실수 타입으로

<br>

### 레퍼런스 타입 캐스팅
업캐스팅은 자동, 다운캐스팅은 명시적으로 해야 함
```java
class A {}
class B extends A {}

A a = new B(); // ⭕
```
- 부모 타입 <- 자식 객체 = 항상 안전
```java
A a = new B();
B b = (B) a; // ⭕

A a = new A();
B b = (B) a; // ❌ ClassCastException
```
- 런타임 타입이 맞지 않으면 예외 발생, instanceof로 방어

---

## 7. 1차 및 2차 배열 선언하기

배열은 같은 타입의 데이터를 연속된 인덱스로 관리하는 자료구조 <br>
자바에서 배열은 객체이며, 따라서 레퍼런스 타입

### 배열의 기본 특징
- 동일한 타입만 저장 가능
- 크기 고정 (생성 후 변경 불가)
- 인덱스는 0부터 시작
- Heap 영역에 생성됨
- 배열 자체는 레퍼런스 타입

<br>

### 1차원 배열 선언 방법
#### 선언만 하기
```java
int[] arr; // 권장 방식
int arr[];
```
- 권장 방식: 타입에 [] 붙이기

#### 선언 + 생성
```java
int[] arr = new int[5];
// {0, 0, 0, 0, 0}
```
- Heap에 배열 객체 생성
- 각 요소는 기본값으로 자동 초기화

#### 선언 + 초기화
```java
int[] arr = {1, 2, 3};
// 컴파일러가 내부적으로 아래처럼 실행
int[] arr = new int[]{1, 2, 3};
```

<br>

### 배열과 메모리 구조
```java
int[] arr = new int[3];
```
- `arr` -> 참조변수 = Stack
- 실제 배열 데이터 -> Heap

<br>

### 2차원 배열 선언
자바의 2차원 배열은 "배열의 배열" 구조

#### 정방향 2차원 배열
```java
int[][] matrix = new int[3][4];
```
```
matrix
  |
  v
[ ref ][ ref ][ ref ]
   |     |     |
  [0][0][0][0]
  [0][0][0][0]
  [0][0][0][0]
```

#### 가변 배열 (Jagged Array)
```java
int[][] jagged = new int[3][];
jagged[0] = new int[2];
jagged[1] = new int[4];
jagged[2] = new int[1];

int[][] jagged = {
    {1, 2},
    {3, 4, 5, 6},
    {7}
};
```
- 위처럼 각 행의 길이가 다르게 선언할 수 있음

<br>

### 알아둘만한 것
- 배열의 길이 `.length`는 필드 / `String.length()`는 메서드
- ArrayIndexOutOfBoundsExceptioon 은 런타임 예외

| 배열     | 컬렉션    |
| ------ | ------ |
| 크기 고정  | 크기 가변  |
| 타입 고정  | 제네릭    |
| 성능 좋음  | 편의성    |
| 낮은 추상화 | 높은 추상화 |


---

## 8. 타입 추론, `var`

`var`은 컴파일러가 초기화 식을 보고 "정적 타입"을 추론하도록 하는 문법 <br>
동적 타입이 아니고, 런타임에 타입이 바뀌지 않는다

### `var`의 본질
```java
var x = 10;
// 위 코드를 컴파일러는
int x = 10;
// 위처럼 처리한다.
```
- `var` = 타입 생략
- 타입 결정 = 컴파일 타임
- 바이트코드에는 명확한 타입 정보가 남는다

<br>

### `var` 사용 가능 범위
var는 로컬 변수, 초기화와 함께로만 사용 가능하다
```java
void foo() {
    var a = 10;
    var b = "hello";
    var c = new ArrayList<String>();
}

// 위는 사용 가능한 경우

class A {
    var x = 10;        // ❌ 필드
    static var y = 20; // ❌ static 필드
}
var x;       // ❌ 초기화 없음
var y = null; // ❌ 타입 추론 불가
void foo(var x) {} // ❌ 파라미터

// 위는 사용 불가능 경우
```

<br>

### `var`에 대한 이모저모
#### `var`를 써도 제네릭 타입 정보가 유지된다
```java
var list = new ArrayList<String>();
list.add("hi");
list.add(10); // ❌ 컴파일 에러
```

#### `var` 는 리터럴 타입 규칙을 그대로 따른다
```java
var a = 10;      // int
var b = 10L;     // long
var c = 3.14;    // double
var d = 3.14f;   // float
```

#### `var` 는 프리미티브 / 레퍼런스 구분이 딱히 없으나 결과 타입은 정확히 하나로 결정된다
```java
var s = "hello";   // String
var i = Integer.valueOf(10); // Integer
```

#### `var`의 다형성
```java
var list = new ArrayList<String>();
List<String> list2 = new ArrayList<>();
```
- `list`: `ArrayList<String>`
- `list2`: `List<String>`
- `var`는 구현 타입에 강제 고정되어 인터페이스로 추상화가 불가능

#### `var`와 가독성
```java
var count = 10;
var name = "java";
var list = new ArrayList<String>();
// 가독성이 좋은 경우
var x = foo(bar(baz()));
// 가독성이 나쁜 경우
```
- 대부분의 경우에 우변만 보고 타입이 명확할 때만 사용
- 실무에서 지양하는 이유: 코드 리뷰 비용 증가 / 디버깅 인지 부하 증가 / API 실수 가능성 증가

#### `var`와 성능
`var`는 컴파일러가 컴파일 시점에 타입을 정해서 바이트코드에는 타입이 명시되기 때문에 성능 차이가 없다
