## 1. JVM(Java Virtual Machine)이란?

JVM(Java Virtual Machine)은 자바 프로그램을 실행하기 위한 가상 머신 <br>
운영체제(os) 위에서 동작하며, 자바의 '플랫폼 독립성'을 제공하는 핵심 요소 <br>

#### 플랫폼 독립성
- `.class`의 바이트코드는 특정 CPU의 기계어가 아니라, JVM의 명령 집합
- OS마다 JVM 구현이 다르게 존재하며, 각각의 JVM이 바이트 코드를 OS/CPU에 맞춰서 실행시킴 -> 같은 `.class`가 여러 os에서 실행 가능

### JVM의 주요 역할
- `.class` 파일(바이트 코드) 실행
- 운영체제 및 하드웨어 차이 추상화
- 메모리 관리(Garbage Collection)
- 스레드 관리
- 런타임 최적화(JIT 컴파일)

---

## 2. 컴파일 하는 방법 (.java -> .class)

### 컴파일이란?
사람이 작성한 자바 소스 코드(`.java`)를 JVM이 이해할 수 있는  
바이트 코드(`.class`)로 변환하는 과정이다.

```bash
javac Hello.java
```
- 결과물 : `Hello.class`
- 이 `.class`는 바이트코드 + 클래스 메타데이터를 담는 "클래스 파일 포맷"

#### 컴파일 상세
- **파싱/구문 분석:** 소스코드를 AST로 만듦
- **심볼 해석/타입 체크:** 타입 오류, 접근 제어, 오버로딩 해석 등
- **어노테이션 프로세싱:** Lombok, MapStruct 등은 여기서 코드 생성/수정 개입
- **바이트코드 생성:** JVM 명령으로 메서드 바디 구성
- **클래스 파일 출력:** constant pool, fields, methods, attributes 구성

---

## 3. 실행하는 방법: `.class -> 실행`

### 기본 실행
```bash
java Hello
```
java 명령은 JVM을 시작하고, 지정한 클래스를 로딩한 뒤 `main` 메서드를 호출하여 애플리케이션을 시작함

### classpath가 중요한 이유
JVM은 실행 시점에 클래스를 어디서 찾을지 알아야함 <br>

이 탐색 결로가 **classpath**
- 기본 탐색 경로는 현재 디렉토리
- 환경변수 CLASSPATH보다 `-cp` 옵션으로 실행 단위마다 지정하는 것을 권장 <br>

classpath를 잘못 잡으면 흔히 `ClassNotFoundException`, `NoClassDefFoundError`가 발생한다.
> ClassNotFoundException: 클래스를 찾으려 시도했으나 classpath에 없음 <br>
> NoClassDefFoundError: 과거에는 존재했으나 로딩/링킹 중 실패 (의존성 누락, static 초기화 실패 등)

### 실행 흐름
1. JVM 프로세스 시작
2. 클래스 로더가 필요한 `.class` 파일 로딩
3. 바이트코드 검증
4. JVM 메모리 영역에 클래스 및 데이터 적재
5. 실행 엔진이 바이트코드 실행
6. `main` 메서드 호출로 프로그램 시작

---

## 4. 바이트코드(Bytecode)란 무엇인가?
바이트코드는 JVM이 이해하는 명령 형태의 중간 코드이며 `.class`에 저장 <br>
플랫폼에 종속되지 않아서 "바이트코드 + JVM" 조합으로 이식성이 확보 (플랫폼 독립성)

### 바이트코드의 특징
- 플랫폼 독립적
- JVM에서만 실행 가능
- 기계어가 아니므로 os에서 직접 실행 불가
- 동일한 바이트 코드를 여러 os의 JVM에서 실행 가능

### 클래스 파일에는 무엇이 들었나?
- **Constant Pool:** 문자열, 클래스/메서드/필드에 대한 심볼릭 레퍼런스, 리터럴 등
- **Fields / Methods:** 멤버 변수/메서드 시그니처와 속성
- **Code Attribute:** 메서드의 바이트코드(실제 실행 명령)
- **기타 Attributes:** 디버깅 정보, annotations, inner class 정보 등

JVM은 로딩 후 "심볼릭 레퍼런스 -> 실제 참조"로 바꿔가며 실행한다.

---

## 5. JIT 컴파일러란 무엇이며 어떻게 동작하는가
JVM은 기본적으로 바이트코드를 인터프리터 방식으로 실행 <br>
하지만 인터프리터 방식은 매번 바이트코드를 해석해야 하므로 성능이 떨어짐 <br>
이를 보완하기 위해 JIT 컴파일러를 사용

### JIT 컴파일러의 역할
- 실행 중 자주 호출되는 코드(HJotSpot)을 감지
- 해당 바이트코드를 기계어로 변환
- 이후 실행 시 해석 과정 없이 바로 실행

### JIT 동작 흐름
1. 프로그램 시작 시 인터프리터 방식으로 실행
2. 실행 중 메서드/루프 호출 횟수 모니터링(프로파일링)
3. 일정 기준 초과 시 HotSpot으로 판단
4. JIT 컴파일러가 기계어로 컴파일
5. 이후에는 컴파일된 코드 재사용

<img width="1600" height="800" alt="image" src="https://github.com/user-attachments/assets/005643c9-eedb-42b6-9bc6-7fe21f621d5d" />

JAVA는 인터프리터 + JIT 컴파일을 결합한 하이브리드 실행 모델

#### 처음부터 네이트브로 컴파일 하지 않는 이유
- 시작 시간이 느려짐(컴파일 비용이 너무 큼)
- 실제로 거의 실행되지 않는 코드에도 비용 낭비됨
- 런타임 정보를 활용한 최적화를 못함

#### Tiered Compliation (단계적 컴파일)
현대 HotSpot JVM은 보통 단계적 컴파일을 사용 <br>
이를 사용하는 이유는 시작속도와 최대 성능을 동시에 잡기 위함 <br>

일반적인 흐름
1. Interpreter: 빠른 시작
2. C1 컴파일: 초반 체감 성능 확보
3. C2 컴파일: 장기 실행 최고 성능 확보

위같은 계층적 컴파일을 통해 초기에 빠르게 시작하면서 점차 성능을 개선시켜 최적화함

#### 대표적인 JIT 최적화 예시
1. 인라이닝(Inlining)
  - 작은 메서도 호출을 함수 호출로 남겨두지 않고 본문을 붙여넣음
  - 호출 오버헤드 감소 + 이후 최적화 기회 증가
2. 루프 최적화
  - 루프 불변식 이동(루프 밖으로 뺌)
  - 반복 중 불필요 연산 제거
  - 분기 예측 개선 등
3. Escape Analysis
  - 객체가 메서드 밖으로 탈출하지 않으면 힙 할당을 줄이거나 제거
  - GC 부담 감소
4. Dead Code Elimination
  - 실행 결과에 영향을 주지 않는 코드를 판단하여 제거

---

## 6. JVM의 구성 요소
JVM은 크게 3가지 영역으로 구성

### 클래스 로더(Class Loader)
- `.class`파일을 JVM 메모리로 로딩
- 로딩 -> 링킹 -> 초기화 단계 수행
- 필요한 시점에 클래스를 동적으로 로딩(lazy loading)

#### 클래스 로딩의 3단계
1. 로딩(Loading)
- 클래스의 바이너리 표현을 읽어 메모리에 적재
- 클래스 이름, 상위 클래스, 인터페이스 정보 등 기본 구조 생성
- 이 단계에서 클래스는 아직 사용 불가 상태
2. 링킹(Linking) <br>
로딩된 클래스가 실행 가능한 상태가 되도록 준비하는 단계로 3부분으로 나뉨
- 검증(Verification)
  - 바이트코드가 JVM 명세에 맞는지 검사
  - 타입 안정성, 스택 오버플로우 가능성 등 확인
  - 악의적인 코드 실행을 방지하는 보안 장치
- 준비(Preparation)
  - 클래스의 `static` 필드에 대해 메모리 할당
  - 초기값은 개발자가 지정한 값이 아니라 기본값(0, null 등)
- 해결(Resolution)
  - 상수 풀(Constant Pool)에 있는 심볼릭 레퍼런스를 실제 참조로 변환
  - 필요 시점까지 지연되다가 실행될 수 있음
3. 초기화(Initialization)
- `static` 변수의 명시적 초기화 수행
- `static {}` 초기화 블록 실행
- 클래스 초기화는 단 한번만 수행됨

### 실행 엔진(Execution Engine)
실행 엔진은 클래스 로더에 의해 메모리에 적재된 바이트코드를 실제로 실행하는 역할

- 인터프리터
  - 바이트 코드를 한 줄씩 읽어서 바로 실행
  - 컴파일 과정이 없어 시작 속도가 빠름
  - 동일한 코드를 반복 실행하면 성능이 떨어짐
- JIT 컴파일러
  - 자주 실행되는 바이트코드를 네이티브코드로 변환
  - 인터프리터의 반복 해석 비용을 제거
  - 런타임에 컴파일 수행
  - HotSpot, Tiered Compilation 등과 결합되어 동작
- 가비지 컬렉터(GC)
  - Heap 영역에서 더이상 참조되지 않는 객체를 탐지하고 메모리 회수
  - 개발자가 명시적으로 메모리를 해제하지 않아도 됨
  - Stop-The-World 등 성능에 직접적인 영향을 미침
바이트코드를 실제로 실행하는 핵심 영역

### 런타임 데이터 영역(Runtime Data Area)
#### 스레드별 영역
- **PC Register:** 현재 실행 중인 명령 주소
- **JVM Stack:** 메서도 호출 정보, 지역 변수
- **Native Method Stack:** 네이티브 코드 실행

#### 공유 영역
- **Heap:** 객체 저장 영역, GC 대상
- **Method Area:** 클래스 메타데이터, static 변수

---

## 7. JDK와 JRE의 차이
### JRE(Java Runtime Environment)
- 자바 실행 환경
- JVM + 자바 표준 라이브러리
- 자바 프로그램 실행만 가능 (컴파일 불가)

### JDK(Java Development Kit)
- 자바 개발 환경
- JRE + 개발 도구
  - `javac`, `jar`, `javadoc` 등
 
### JRE와 JDK를 왜 분리 했을까?
개발과 운영의 분리
- 개발자 PC: JDK 필요(컴파일 + 디버깅 + 실행)
- 운영 서버: JRE만 있으면 컴파일된 것을 실행시키면 됨

분리를 통한 이점
- 운영 환경의 크기 축소
- 불필요한 개발 도구 제거
- 보안 위험 감소

관계 정리
```
JDK ⊃ JRE ⊃ JVM
```

#### Java11 버전 이후
별도의 JRE 배포가 공식적으로 중단되고 JDK만 제공 <br>
JDK 하나로 개발/실행을 모두 커버하고, 필요한 경우 커스텀 런타임을 만듬
