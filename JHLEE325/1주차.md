## 1. JVM(Java Virtual Machine)이란?

JVM(Java Virtual Machine)은 자바 프로그램을 실행하기 위한 가상 머신 <br>
운영체제(os) 위에서 동작하며, 자바의 '플랫폼 독립성'을 제공하는 핵심 요소 <br>

#### 플랫폼 독립성
- `.class`의 바이트코드는 특정 CPU의 기계어가 아니라, JVM의 명령 집합
- OS마다 JVM 구현이 다르게 존재하며, 각각의 JVM이 바이트 코드를 OS/CPU에 맞춰서 실행시킴 -> 같은 `.class`가 여러 os에서 실행 가능

### JVM의 주요 역할
- `.class` 파일(바이트 코드) 실행
- 운영체제 및 하드웨어 차이 추상화
- 메모리 관리(Garbage Collection)
- 스레드 관리
- 런타임 최적화(JIT 컴파일)

---

## 2. 컴파일 하는 방법 (.java -> .class)

### 컴파일이란?
사람이 작성한 자바 소스 코드(`.java`)를 JVM이 이해할 수 있는  
바이트 코드(`.class`)로 변환하는 과정이다.

```bash
javac Hello.java
```
- 결과물 : `Hello.class`
- 이 `.class`는 바이트코드 + 클래스 메타데이터를 담는 "클래스 파일 포맷"

#### 컴파일 상세
- **파싱/구문 분석:** 소스코드를 AST로 만듦
- **심볼 해석/타입 체크:** 타입 오류, 접근 제어, 오버로딩 해석 등
- **어노테이션 프로세싱:** Lombok, MapStruct 등은 여기서 코드 생성/수정 개입
- **바이트코드 생성:** JVM 명령으로 메서드 바디 구성
- **클래스 파일 출력:** constant pool, fields, methods, attributes 구성

---

## 3. 실행하는 방법: `.class -> 실행`

### 기본 실행
```bash
java Hello
```
java 명령은 JVM을 시작하고, 지정한 클래스를 로딩한 뒤 `main` 메서드를 호출하여 애플리케이션을 시작함

### classpath가 중요한 이유
JVM은 실행 시점에 클래스를 어디서 찾을지 알아야함 <br>

이 탐색 결로가 **classpath**
- 기본 탐색 경로는 현재 디렉토리
- 환경변수 CLASSPATH보다 `-cp` 옵션으로 실행 단위마다 지정하는 것을 권장 <br>

classpath를 잘못 잡으면 흔히 `ClassNotFoundException`, `NoClassDefFoundError`가 발생한다.

### 실행 흐름
1. JVM 프로세스 시작
2. 클래스 로더가 필요한 `.class` 파일 로딩
3. 바이트코드 검증
4. JVM 메모리 영역에 클래스 및 데이터 적재
5. 실행 엔진이 바이트코드 실행
6. `main` 메서드 호출로 프로그램 시작

---

## 4. 바이트코드(Bytecode)란 무엇인가?
바이트코드는 JVM이 이해하는 명령 형태의 중간 코드이며 `.class`에 저장 <br>
플랫폼에 종속되지 않아서 "바이트코드 + JVM" 조합으로 이식성이 확보 (플랫폼 독립성)

### 바이트코드의 특징
- 플랫폼 독립적
- JVM에서만 실행 가능
- 기계어가 아니므로 os에서 직접 실행 불가
- 동일한 바이트 코드를 여러 os의 JVM에서 실행 가능

### 클래스 파일에는 무엇이 들었나?
- **Constant Pool:** 문자열, 클래스/메서드/필드에 대한 심볼릭 레퍼런스, 리터럴 등
- **Fields / Methods:** 멤버 변수/메서드 시그니처와 속성
- **Code Attribute:** 메서드의 바이트코드(실제 실행 명령)
- **기타 Attributes:** 디버깅 정보, annotations, inner class 정보 등

JVM은 로딩 후 "심볼릭 레퍼런스 -> 실제 참조"로 바꿔가며 실행한다.

---

## 5. JIT 컴파일러란 무엇이며 어떻게 동작하는가
JVM은 기본적으로 바이트코드를 인터프리터 방식으로 실행 <br>
하지만 인터프리터 방식은 매번 바이트코드를 해석해야 하므로 성능이 떨어짐 <br>
이를 보완하기 위해 JIT 컴파일러를 사용

### JIT 컴파일러의 역할
- 실행 중 자주 호출되는 코드(HJotSpot)을 감지
- 해당 바이트코드를 기계어로 변환
- 이후 실행 시 해석 과정 없이 바로 실행

### JIT 동작 흐름
1. 프로그램 시작 시 인터프리터 방식으로 실행
2. 실행 중 메서드/루프 호출 횟수 모니터링
3. 일정 기준 초과 시 HotSpot으로 판단
4. JIT 컴파일러가 기계어로 컴파일
5. 이후에는 컴파일된 코드 재사용

JAVA는 인터프리터 + JIT 컴파일을 결합한 하이브리드 실행 모델

---

## 6. JVM의 구성 요소
JVM은 크게 3가지 영역으로 구성

### 클래스 로더(Class Loader)
- `.class`파일을 JVM 메모리로 로딩
- 로딩 -> 링킹 -> 초기화 단계 수행
- 필요한 시점에 클래스를 동적으로 로딩

### 실행 엔진(Execution Engine)
- 인터프리터
- JIT 컴파일러
- 가비지 컬렉터(GC)
바이트코드를 실제로 실행하는 핵심 영역

### 런타임 데이터 영역(Runtime Data Area)
#### 스레드별 영역
- **PC Register:** 현재 실행 중인 명령 주소
- **JVM Stack:** 메서도 호출 정보, 지역 변수
- **Native Method Stack:** 네이티브 코드 실행

#### 공유 영역
- **Heap:** 객체 저장 영역, GC 대상
- **Method Area:** 클래스 메타데이터, static 변수

---

## 7. JDK와 JRE의 차이
### JRE(Java Runtime Environment)
- 자바 실행 환경
- JVM + 자바 표준 라이브러리
- 자바 프로그램 실행만 가능

### JDK(Java Development Kit)
- 자바 개발 환경
- JRE + 개발 도구
  - `javac`, `jar`, `javadoc` 등

관계 정리
```
JDK ⊃ JRE ⊃ JVM
```
